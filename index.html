import React, { useState, useEffect, useCallback } from 'react';

// --- ICONS (as SVG components) ---
const FolderIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#FFC107" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>;
const PdfFileIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#F44336" strokeWidth="1.5"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>;
const ImageFileIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#8B5CF6" strokeWidth="1.5"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>;
const DeleteIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>;
const PrintIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M5 4v3H4a2 2 0 00-2 2v6a2 2 0 002 2h12a2 2 0 002-2V9a2 2 0 00-2-2h-1V4a2 2 0 00-2-2H7a2 2 0 00-2 2zm8 0H7v3h6V4zm0 8H7v4h6v-4z" clipRule="evenodd" /></svg>;
const SparklesIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M5 2a1 1 0 00-1 1v1.586l-1.293 1.293a1 1 0 001.414 1.414L5 6.414V8a1 1 0 002 0V6.414l.293.293a1 1 0 001.414-1.414L7.414 4.586V3a1 1 0 00-1-1H5zM10 8a1 1 0 00-1 1v1.586l-1.293 1.293a1 1 0 101.414 1.414L10 12.414V14a1 1 0 102 0v-1.586l.293.293a1 1 0 101.414-1.414L12.414 10.586V9a1 1 0 00-1-1h-1zM15 2a1 1 0 00-1 1v1.586l-1.293 1.293a1 1 0 101.414 1.414L15 6.414V8a1 1 0 102 0V6.414l.293.293a1 1 0 101.414-1.414L17.414 4.586V3a1 1 0 00-1-1h-1z" clipRule="evenodd" /></svg>;


// --- Helper Functions ---
const generateId = (prefix) => `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

// --- Main App Component ---
export default function App() {
    const [folders, setFolders] = useState([]);
    const [files, setFiles] = useState([]);
    const [currentFolderId, setCurrentFolderId] = useState(null);
    const [modal, setModal] = useState({ type: null, data: null }); // type: 'addFolder' | 'delete' | 'processFile' | 'summarize'

    // Load state from localStorage on initial render
    useEffect(() => {
        try {
            const savedState = localStorage.getItem('aktenOrdnerState');
            if (savedState) {
                const { folders, files } = JSON.parse(savedState);
                setFolders(folders || []);
                setFiles(files || []);
            } else {
                const CURRENT_YEAR = new Date().getFullYear();
                setFolders([
                    { id: generateId('folder'), name: `Steuererklärung ${CURRENT_YEAR}`, parentId: null },
                    { id: generateId('folder'), name: 'Mieter', parentId: null },
                ]);
            }
        } catch (error) {
            console.error("Failed to load state from localStorage:", error);
        }
    }, []);

    // Save state to localStorage whenever folders or files change
    useEffect(() => {
        try {
            const stateToSave = JSON.stringify({ folders, files });
            localStorage.setItem('aktenOrdnerState', stateToSave);
        } catch (error) {
            console.error("Failed to save state to localStorage:", error);
        }
    }, [folders, files]);

    const handleAddFolder = (name) => {
        if (!name.trim()) return;
        const newFolder = { id: generateId('folder'), name, parentId: currentFolderId };
        setFolders(prev => [...prev, newFolder]);
        setModal({ type: null, data: null });
    };

    const handleFileUpload = (uploadedFile) => {
        if (!uploadedFile || !currentFolderId) return;
        // Simulate reading file content (OCR)
        const simulatedContent = `RECHNUNG\nFirma Handwerker GmbH\nRechnungsnummer: 2025-08-15\nFällig bis: 30.08.2025\nBetrag: 123.45 EUR\nSehr geehrte Damen und Herren, anbei die Rechnung für die Reparatur des Wasserhahns.`;
        setModal({ type: 'processFile', data: { originalFile: uploadedFile, content: simulatedContent, targetFolderId: currentFolderId } });
    };
    
    const handleSaveProcessedFile = ({ fileName, folderName }) => {
        let targetFolder = folders.find(f => f.name.toLowerCase() === folderName.toLowerCase() && f.parentId === null);
        
        if (!targetFolder) {
            targetFolder = { id: generateId('folder'), name: folderName, parentId: null };
            setFolders(prev => [...prev, targetFolder]);
        }

        const newFile = {
            id: generateId('file'),
            name: fileName,
            date: new Date().toISOString(),
            folderId: targetFolder.id,
        };
        setFiles(prev => [...prev, newFile]);
        setModal({ type: null, data: null });
    };

    const handleDelete = () => {
        if (!modal.data) return;
        const { type, id } = modal.data;

        if (type === 'file') {
            setFiles(prev => prev.filter(file => file.id !== id));
        } else if (type === 'folder') {
            const foldersToDelete = new Set([id]);
            let changed = true;
            while(changed) {
                changed = false;
                const currentSize = foldersToDelete.size;
                folders.forEach(folder => {
                    if (folder.parentId && foldersToDelete.has(folder.parentId)) {
                        foldersToDelete.add(folder.id);
                    }
                });
                if (foldersToDelete.size > currentSize) changed = true;
            }
            
            setFiles(prev => prev.filter(file => !foldersToDelete.has(file.folderId)));
            setFolders(prev => prev.filter(folder => !foldersToDelete.has(folder.id)));
        }
        setModal({ type: null, data: null });
    };
    
    const handleExport = () => {
        const dataStr = JSON.stringify({ folders, files }, null, 2);
        const dataBlob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.download = 'akten-ordner-backup.json';
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
        alert('Sicherungsdatei wurde im Downloads-Ordner gespeichert.');
    };

    const handleImport = (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const { folders: importedFolders, files: importedFiles } = JSON.parse(e.target.result);
                if (Array.isArray(importedFolders) && Array.isArray(importedFiles)) {
                    if (window.confirm('Möchten Sie wirklich alle aktuellen Daten durch den Inhalt der Sicherungsdatei ersetzen?')) {
                        setFolders(importedFolders);
                        setFiles(importedFiles);
                        setCurrentFolderId(null);
                        alert('Daten erfolgreich wiederhergestellt!');
                    }
                } else {
                    alert('Fehler: Die Datei hat kein gültiges Format.');
                }
            } catch (error) {
                alert('Fehler beim Lesen der Datei.');
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    };

    const currentFolder = folders.find(f => f.id === currentFolderId);
    const childFolders = folders.filter(f => f.parentId === currentFolderId);
    const childFiles = files.filter(f => f.folderId === currentFolderId).sort((a, b) => new Date(b.date) - new Date(a.date));

    return (
        <div className="flex flex-col h-screen bg-slate-100 font-sans">
            <Header
                currentFolder={currentFolder}
                onBack={() => setCurrentFolderId(currentFolder?.parentId ?? null)}
                onImport={handleImport}
                onExport={handleExport}
                onSummarize={() => setModal({ type: 'summarize', data: { folderName: currentFolder.name, files: childFiles }})}
            />
            <MainContent
                folders={childFolders}
                files={childFiles}
                onFolderClick={setCurrentFolderId}
                onDeleteClick={(item) => setModal({ type: 'delete', data: item })}
            />
            <ActionButtons
                currentFolderId={currentFolderId}
                onAddFolderClick={() => setModal({ type: 'addFolder', data: null })}
                onFileUpload={handleFileUpload}
            />
            {modal.type === 'addFolder' && <AddFolderModal onAdd={handleAddFolder} onCancel={() => setModal({ type: null, data: null })} />}
            {modal.type === 'delete' && <DeleteModal onDelete={handleDelete} onCancel={() => setModal({ type: null, data: null })} itemType={modal.data.type} />}
            {modal.type === 'processFile' && <FileProcessingModal data={modal.data} onSave={handleSaveProcessedFile} onCancel={() => setModal({ type: null, data: null })} existingFolders={folders.filter(f => f.parentId === null)}/>}
            {modal.type === 'summarize' && <SummaryModal data={modal.data} onCancel={() => setModal({ type: null, data: null })} />}
        </div>
    );
}

// --- Child Components ---

function Header({ currentFolder, onBack, onImport, onExport, onSummarize }) {
    return (
        <header className="bg-blue-600 text-white shadow-md p-4 flex items-center justify-between">
            <button onClick={onBack} className={`p-2 rounded-full hover:bg-blue-700 ${!currentFolder ? 'invisible' : ''}`}>
                <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>
            </button>
            <h1 className="text-xl font-bold text-center truncate">{currentFolder?.name || 'Hauptmenü'}</h1>
            <div className="flex items-center space-x-2">
                {currentFolder && (
                     <button onClick={onSummarize} title="Ordner zusammenfassen" className="p-2 rounded-full hover:bg-blue-700">
                        <SparklesIcon />
                    </button>
                )}
                <label htmlFor="import-input" className="p-2 rounded-full hover:bg-blue-700 cursor-pointer" title="Daten Wiederherstellen">
                    <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                </label>
                <input type="file" id="import-input" className="hidden" accept=".json" onChange={onImport} />
                <button onClick={onExport} title="Daten Sichern" className="p-2 rounded-full hover:bg-blue-700">
                    <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                </button>
            </div>
        </header>
    );
}

function MainContent({ folders, files, onFolderClick, onDeleteClick }) {
    if (folders.length === 0 && files.length === 0) {
        return <main className="flex-grow p-4 overflow-y-auto h-full flex items-center justify-center text-slate-500"><p>Dieser Ordner ist leer.</p></main>;
    }
    return (
        <main className="flex-grow p-4 overflow-y-auto">
            <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-4">
                {folders.map(folder => (
                    <div key={folder.id} onClick={() => onFolderClick(folder.id)} className="relative aspect-square bg-white rounded-lg shadow p-2 cursor-pointer text-center flex flex-col items-center justify-center">
                        <FolderIcon />
                        <span className="mt-2 text-sm font-medium text-slate-700 break-words">{folder.name}</span>
                        <div onClick={(e) => { e.stopPropagation(); onDeleteClick({ id: folder.id, type: 'folder' }); }} className="absolute top-1 right-1 p-1 text-slate-400 hover:text-red-500 rounded-full"><DeleteIcon /></div>
                    </div>
                ))}
                {files.map(file => {
                    const isPdf = file.name.toLowerCase().endsWith('.pdf');
                    return (
                        <div key={file.id} className="relative aspect-square bg-white rounded-lg shadow p-2 text-center flex flex-col items-center justify-center">
                            {isPdf ? <PdfFileIcon /> : <ImageFileIcon />}
                            <span className="mt-2 text-sm font-medium text-slate-700 break-words">{file.name}</span>
                            <div onClick={(e) => { e.stopPropagation(); onDeleteClick({ id: file.id, type: 'file' }); }} className="absolute top-1 right-1 p-1 text-slate-400 hover:text-red-500 rounded-full"><DeleteIcon /></div>
                            <div onClick={() => alert('Drucken ist in diesem Prototyp nicht möglich.')} className="absolute bottom-1 right-1 p-1 text-slate-400 hover:text-blue-500 rounded-full"><PrintIcon /></div>
                        </div>
                    );
                })}
            </div>
        </main>
    );
}

function ActionButtons({ currentFolderId, onAddFolderClick, onFileUpload }) {
    return (
        <div className="fixed bottom-6 right-6 flex flex-col items-end space-y-3">
            {currentFolderId && (
                <label htmlFor="file-upload-input" className="bg-green-500 hover:bg-green-600 text-white rounded-full w-14 h-14 flex items-center justify-center shadow-lg cursor-pointer" title="Datei in Ordner hochladen">
                     <svg className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M12 15l-4-4m0 0l4-4m-4 4h12" /></svg>
                </label>
            )}
             <input type="file" id="file-upload-input" className="hidden" accept="image/*,.pdf" onChange={(e) => onFileUpload(e.target.files[0])} />
            <button onClick={onAddFolderClick} className="bg-blue-500 hover:bg-blue-600 text-white rounded-full w-14 h-14 flex items-center justify-center shadow-lg" title="Neuen Ordner erstellen">
                <svg className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z" /></svg>
            </button>
        </div>
    );
}

function AddFolderModal({ onAdd, onCancel }) {
    const [name, setName] = useState('');
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
            <div className="bg-white rounded-lg p-6 shadow-xl w-11/12 max-w-sm">
                <h2 className="text-lg font-bold mb-4">Neuen Ordner erstellen</h2>
                <input type="text" value={name} onChange={(e) => setName(e.target.value)} className="border rounded-md w-full p-2 mb-4" placeholder="Name des Ordners" autoFocus />
                <div className="flex justify-end space-x-2">
                    <button onClick={onCancel} className="bg-gray-300 hover:bg-gray-400 text-black px-4 py-2 rounded-md">Abbrechen</button>
                    <button onClick={() => onAdd(name)} className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md">Erstellen</button>
                </div>
            </div>
        </div>
    );
}

function DeleteModal({ onDelete, onCancel, itemType }) {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
            <div className="bg-white rounded-lg p-6 shadow-xl w-11/12 max-w-sm text-center">
                <h2 className="text-lg font-bold mb-2">Wirklich löschen?</h2>
                <p className="mb-4 text-slate-600">{`Möchten Sie das ${itemType === 'folder' ? 'Verzeichnis (inkl. Inhalt)' : 'Dokument'} wirklich löschen?`}</p>
                <div className="flex justify-center space-x-2">
                    <button onClick={onCancel} className="bg-gray-300 hover:bg-gray-400 text-black px-4 py-2 rounded-md">Nein</button>
                    <button onClick={onDelete} className="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md">Ja, löschen</button>
                </div>
            </div>
        </div>
    );
}

function FileProcessingModal({ data, onSave, onCancel, existingFolders }) {
    const { originalFile, content } = data;
    const [fileName, setFileName] = useState(originalFile.name);
    const [folderName, setFolderName] = useState('');
    const [tasks, setTasks] = useState([]);
    const [isLoading, setIsLoading] = useState({ suggestions: false, tasks: false });
    const [error, setError] = useState({ suggestions: '', tasks: '' });

    const getSuggestionsFromGemini = useCallback(async () => {
        setIsLoading(prev => ({ ...prev, suggestions: true }));
        setError(prev => ({ ...prev, suggestions: '' }));
        // ... (rest of the function is the same)
        const topLevelFolders = existingFolders.map(f => f.name).join(', ');
        const prompt = `Analysiere den folgenden Dokumententext und schlage einen passenden Ordner und einen aussagekräftigen Dateinamen vor. Der Dateiname sollte dem Format 'JJJJ-MM-TT_Beschreibung.pdf' folgen. Existierende Hauptordner sind: "${topLevelFolders}". Wenn keiner passt, schlage einen neuen, passenden Ordnernamen vor. Gib deine Antwort als JSON-Objekt. Dokumententext: "${content}"`;
        const schema = { type: "OBJECT", properties: { suggestedFolderName: { type: "STRING" }, suggestedFileName: { type: "STRING" } }, required: ["suggestedFolderName", "suggestedFileName"] };
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: schema } };
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API-Fehler: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates[0].content.parts[0].text;
            const parsedJson = JSON.parse(jsonText);
            setFileName(parsedJson.suggestedFileName);
            setFolderName(parsedJson.suggestedFolderName);
        } catch (err) {
            console.error("Fehler bei der Gemini-API-Anfrage:", err);
            setError(prev => ({ ...prev, suggestions: "Vorschläge konnten nicht geladen werden." }));
        } finally {
            setIsLoading(prev => ({ ...prev, suggestions: false }));
        }
    }, [content, existingFolders]);
    
    const getTasksFromGemini = useCallback(async () => {
        setIsLoading(prev => ({ ...prev, tasks: true }));
        setError(prev => ({ ...prev, tasks: '' }));
        setTasks([]);

        const prompt = `Basierend auf diesem Dokumententext, schlage 1-3 relevante, ausführbare Aufgaben vor. Beispiel: Für eine Rechnung mit Fälligkeitsdatum, schlage vor, sie zu bezahlen. Gib die Antwort als JSON-Array von Strings. Text: "${content}"`;
        const schema = { type: "ARRAY", items: { type: "STRING" } };
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: schema } };

        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API-Fehler: ${response.statusText}`);
            const result = await response.json();
            const jsonText = result.candidates[0].content.parts[0].text;
            const parsedJson = JSON.parse(jsonText);
            setTasks(parsedJson);
        } catch (err) {
            console.error("Fehler bei der Gemini-API-Anfrage für Aufgaben:", err);
            setError(prev => ({ ...prev, tasks: "Aufgaben konnten nicht geladen werden." }));
        } finally {
            setIsLoading(prev => ({ ...prev, tasks: false }));
        }
    }, [content]);


    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4">
            <div className="bg-white rounded-lg p-6 shadow-xl w-full max-w-md">
                <h2 className="text-lg font-bold mb-4">Datei verarbeiten</h2>
                <div className="mb-4">
                    <label className="block text-sm font-medium text-gray-700 mb-1">Erkannter Text (simuliert)</label>
                    <textarea className="border rounded-md w-full p-2 h-20 bg-gray-50" readOnly value={content}></textarea>
                </div>
                
                <div className="grid grid-cols-2 gap-2 mb-4">
                    <button onClick={getSuggestionsFromGemini} disabled={isLoading.suggestions} className="w-full flex items-center justify-center bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-md disabled:bg-purple-300">
                        <SparklesIcon /> <span className="ml-2">{isLoading.suggestions ? 'Analysiere...' : '✨ Sortieren'}</span>
                    </button>
                     <button onClick={getTasksFromGemini} disabled={isLoading.tasks} className="w-full flex items-center justify-center bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-md disabled:bg-teal-300">
                        <SparklesIcon /> <span className="ml-2">{isLoading.tasks ? 'Analysiere...' : '✨ Aufgaben'}</span>
                    </button>
                </div>

                {error.suggestions && <p className="text-red-500 text-sm text-center mb-2">{error.suggestions}</p>}
                {error.tasks && <p className="text-red-500 text-sm text-center mb-2">{error.tasks}</p>}

                {tasks.length > 0 && (
                    <div className="mb-4 p-3 bg-teal-50 border border-teal-200 rounded-lg">
                        <h3 className="text-sm font-bold text-teal-800 mb-2">Vorgeschlagene Aufgaben:</h3>
                        <ul className="list-disc list-inside text-sm text-teal-700 space-y-1">
                            {tasks.map((task, index) => <li key={index}>{task}</li>)}
                        </ul>
                    </div>
                )}

                <div className="mb-4">
                    <label htmlFor="folderName" className="block text-sm font-medium text-gray-700 mb-1">Ordner</label>
                    <input id="folderName" type="text" value={folderName} onChange={(e) => setFolderName(e.target.value)} className="border rounded-md w-full p-2" placeholder="Ordnername" />
                </div>
                <div className="mb-6">
                    <label htmlFor="fileName" className="block text-sm font-medium text-gray-700 mb-1">Dateiname</label>
                    <input id="fileName" type="text" value={fileName} onChange={(e) => setFileName(e.target.value)} className="border rounded-md w-full p-2" placeholder="Dateiname" />
                </div>

                <div className="flex justify-end space-x-2">
                    <button onClick={onCancel} className="bg-gray-300 hover:bg-gray-400 text-black px-4 py-2 rounded-md">Abbrechen</button>
                    <button onClick={() => onSave({ fileName, folderName, originalFile })} className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md">Speichern</button>
                </div>
            </div>
        </div>
    );
}

function SummaryModal({ data, onCancel }) {
    const { folderName, files } = data;
    const [summary, setSummary] = useState('');
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState('');

    const getSummaryFromGemini = useCallback(async () => {
        if (files.length === 0) {
            setSummary("Dieser Ordner enthält keine Dateien, die zusammengefasst werden könnten.");
            setIsLoading(false);
            return;
        }

        setIsLoading(true);
        setError('');
        
        const fileNames = files.map(f => f.name).join(', ');
        const prompt = `Basierend auf der folgenden Liste von Dateinamen aus dem Ordner "${folderName}", erstelle eine kurze Zusammenfassung (1-2 Sätze) über den wahrscheinlichen Inhalt dieses Ordners. Dateinamen: ${fileNames}`;
        
        const apiKey = ""; // Wird von der Umgebung bereitgestellt
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        const payload = {
            contents: [{ parts: [{ text: prompt }] }]
        };
        
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) throw new Error(`API-Fehler: ${response.statusText}`);
            
            const result = await response.json();
            const text = result.candidates[0].content.parts[0].text;
            setSummary(text);

        } catch (err) {
            console.error("Fehler bei der Gemini-API-Anfrage:", err);
            setError("Die Zusammenfassung konnte nicht geladen werden.");
        } finally {
            setIsLoading(false);
        }
    }, [folderName, files]);

    useEffect(() => {
        getSummaryFromGemini();
    }, [getSummaryFromGemini]);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4">
            <div className="bg-white rounded-lg p-6 shadow-xl w-full max-w-md">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-lg font-bold">✨ KI-Zusammenfassung</h2>
                    <button onClick={onCancel} className="text-gray-400 hover:text-gray-600">&times;</button>
                </div>
                <div className="min-h-[100px]">
                    {isLoading && <p className="text-center text-gray-500">Zusammenfassung wird erstellt...</p>}
                    {error && <p className="text-red-500 text-center">{error}</p>}
                    {!isLoading && !error && <p className="text-gray-700">{summary}</p>}
                </div>
                 <div className="flex justify-end mt-4">
                    <button onClick={onCancel} className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md">Schließen</button>
                </div>
            </div>
        </div>
    );
}
