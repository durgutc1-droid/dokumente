<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Akten Ordner</title>
    <meta name="theme-color" content="#3B82F6"/>
    <link rel="manifest" href="data:application/manifest+json,{
        &quot;name&quot;: &quot;Akten Ordner&quot;,
        &quot;short_name&quot;: &quot;Akten&quot;,
        &quot;start_url&quot;: &quot;.&quot;,
        &quot;display&quot;: &quot;standalone&quot;,
        &quot;background_color&quot;: &quot;#F1F5F9&quot;,
        &quot;theme_color&quot;: &quot;#3B82F6&quot;,
        &quot;description&quot;: &quot;Eine App zur Verwaltung Ihrer Dokumente.&quot;,
        &quot;icons&quot;: [{
            &quot;src&quot;: &quot;https://www.gstatic.com/images/branding/product/1x/drive_2020q4_48dp.png&quot;,
            &quot;sizes&quot;: &quot;48x48&quot;,
            &quot;type&quot;: &quot;image/png&quot;
        }, {
            &quot;src&quot;: &quot;https://www.gstatic.com/images/branding/product/1x/drive_2020q4_96dp.png&quot;,
            &quot;sizes&quot;: &quot;96x96&quot;,
            &quot;type&quot;: &quot;image/png&quot;
        }, {
            &quot;src&quot;: &quot;https://www.gstatic.com/images/branding/product/2x/drive_2020q4_192dp.png&quot;,
            &quot;sizes&quot;: &quot;192x192&quot;,
            &quot;type&quot;: &quot;image/png&quot;
        }, {
            &quot;src&quot;: &quot;https://ssl.gstatic.com/images/branding/product/2x/drive_2020q4_512dp.png&quot;,
            &quot;sizes&quot;: &quot;512x512&quot;,
            &quot;type&quot;: &quot;image/png&quot;
        }]
    }">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel Compiler -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; -webkit-tap-highlight-color: transparent; }
        .modal-backdrop { z-index: 50; }
        .grid-item { aspect-ratio: 1 / 1; }
        .icon-btn { width: 2rem; height: 2rem; }
    </style>
</head>
<body class="bg-slate-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // --- ICONS (as SVG components) ---
        const FolderIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#FFC107" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>;
        const PdfFileIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#F44336" strokeWidth="1.5"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>;
        const ImageFileIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#8B5CF6" strokeWidth="1.5"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>;
        const DeleteIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>;
        const SparklesIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M5 2a1 1 0 00-1 1v1.586l-1.293 1.293a1 1 0 001.414 1.414L5 6.414V8a1 1 0 002 0V6.414l.293.293a1 1 0 001.414-1.414L7.414 4.586V3a1 1 0 00-1-1H5zM10 8a1 1 0 00-1 1v1.586l-1.293 1.293a1 1 0 101.414 1.414L10 12.414V14a1 1 0 102 0v-1.586l.293.293a1 1 0 101.414-1.414L12.414 10.586V9a1 1 0 00-1-1h-1zM15 2a1 1 0 00-1 1v1.586l-1.293 1.293a1 1 0 101.414 1.414L15 6.414V8a1 1 0 102 0V6.414l.293.293a1 1 0 101.414-1.414L17.414 4.586V3a1 1 0 00-1-1h-1z" clipRule="evenodd" /></svg>;

        const generateId = (prefix) => `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        // --- IndexedDB Helper for storing file blobs ---
        const dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open("AktenOrdnerPWA_DB", 1);
            request.onerror = () => reject("IndexedDB error:", request.error);
            request.onsuccess = () => resolve(request.result);
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('fileContents')) {
                    db.createObjectStore('fileContents', { keyPath: 'id' });
                }
            };
        });

        const fileStore = {
            async get(key) {
                const db = await dbPromise;
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('fileContents', 'readonly');
                    const store = tx.objectStore('fileContents');
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result?.blob);
                    request.onerror = () => reject(request.error);
                });
            },
            async set(key, val) {
                const db = await dbPromise;
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('fileContents', 'readwrite');
                    const store = tx.objectStore('fileContents');
                    const request = store.put({ id: key, blob: val });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },
            async delete(key) {
                const db = await dbPromise;
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('fileContents', 'readwrite');
                    const store = tx.objectStore('fileContents');
                    const request = store.delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },
        };

        function App() {
            const [folders, setFolders] = useState([]);
            const [files, setFiles] = useState([]);
            const [currentFolderId, setCurrentFolderId] = useState(null);
            const [modal, setModal] = useState({ type: null, data: null });

            useEffect(() => {
                try {
                    const savedState = localStorage.getItem('aktenOrdnerState_PWA');
                    if (savedState) {
                        const { folders, files } = JSON.parse(savedState);
                        setFolders(folders || []);
                        setFiles(files || []);
                    } else {
                        const CURRENT_YEAR = new Date().getFullYear();
                        setFolders([
                            { id: generateId('folder'), name: `Steuererklärung ${CURRENT_YEAR}`, parentId: null },
                            { id: generateId('folder'), name: 'Mieter', parentId: null },
                        ]);
                    }
                } catch (error) { console.error("Failed to load state:", error); }
            }, []);

            useEffect(() => {
                try {
                    localStorage.setItem('aktenOrdnerState_PWA', JSON.stringify({ folders, files }));
                } catch (error) { console.error("Failed to save state:", error); }
            }, [folders, files]);

            const handleAddFolder = (name) => {
                if (!name.trim()) return;
                setFolders(prev => [...prev, { id: generateId('folder'), name, parentId: currentFolderId }]);
                setModal({ type: null, data: null });
            };

            const handleFileUpload = (uploadedFile) => {
                if (!uploadedFile || !currentFolderId) return;
                const simulatedContent = `RECHNUNG\nFirma Handwerker GmbH\nRechnungsnummer: 2025-08-15\nFällig bis: 30.08.2025\nBetrag: 123.45 EUR\nReparatur des Wasserhahns.`;
                setModal({ type: 'processFile', data: { originalFile: uploadedFile, content: simulatedContent } });
            };
            
            const handleSaveProcessedFile = async ({ fileName, folderName, originalFile }) => {
                let targetFolder = folders.find(f => f.name.toLowerCase() === folderName.toLowerCase() && f.parentId === null);
                if (!targetFolder) {
                    targetFolder = { id: generateId('folder'), name: folderName, parentId: null };
                    setFolders(prev => [...prev, targetFolder]);
                }
                const newFile = { id: generateId('file'), name: fileName, date: new Date().toISOString(), folderId: targetFolder.id };
                
                try {
                    await fileStore.set(newFile.id, originalFile);
                    setFiles(prev => [...prev, newFile]);
                    setModal({ type: null, data: null });
                } catch (error) {
                    console.error("Failed to save file blob:", error);
                    alert("Datei konnte nicht im Browser gespeichert werden.");
                }
            };

            const handleDelete = async () => {
                if (!modal.data) return;
                const { type, id } = modal.data;
                if (type === 'file') {
                    try {
                        await fileStore.delete(id);
                        setFiles(prev => prev.filter(file => file.id !== id));
                    } catch (error) { console.error("Could not delete file blob:", error); }
                } else if (type === 'folder') {
                    const foldersToDelete = new Set([id]);
                    let changed = true;
                    while(changed) {
                        changed = false;
                        const currentSize = foldersToDelete.size;
                        folders.forEach(f => { if (f.parentId && foldersToDelete.has(f.parentId)) foldersToDelete.add(f.id); });
                        if (foldersToDelete.size > currentSize) changed = true;
                    }
                    
                    const filesInDeletedFolders = files.filter(file => foldersToDelete.has(file.folderId));
                    for (const file of filesInDeletedFolders) {
                        try {
                            await fileStore.delete(file.id);
                        } catch (error) { console.error(`Could not delete blob for file ${file.id}:`, error); }
                    }
                    setFiles(prev => prev.filter(file => !foldersToDelete.has(file.folderId)));
                    setFolders(prev => prev.filter(folder => !foldersToDelete.has(folder.id)));
                }
                setModal({ type: null, data: null });
            };
            
            const handleExport = () => { /* ... unchanged ... */ };
            const handleImport = (event) => { /* ... unchanged ... */ };

            const handleFileClick = async (file) => {
                try {
                    const blob = await fileStore.get(file.id);
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        window.open(url, '_blank');
                    } else {
                        alert("Dateiinhalt nicht gefunden. Möglicherweise wurden die Browser-Daten gelöscht.");
                    }
                } catch (error) {
                    console.error("Could not open file:", error);
                    alert("Datei konnte nicht geöffnet werden.");
                }
            };

            const currentFolder = folders.find(f => f.id === currentFolderId);
            const childFolders = folders.filter(f => f.parentId === currentFolderId);
            const childFiles = files.filter(f => f.folderId === currentFolderId).sort((a, b) => new Date(b.date) - new Date(a.date));

            return (
                <div className="flex flex-col h-screen bg-slate-100 font-sans">
                    <Header
                        currentFolder={currentFolder}
                        onBack={() => setCurrentFolderId(currentFolder?.parentId ?? null)}
                        onImport={handleImport}
                        onExport={handleExport}
                        onSummarize={() => setModal({ type: 'summarize', data: { folderName: currentFolder.name, files: childFiles }})}
                    />
                    <MainContent
                        folders={childFolders}
                        files={childFiles}
                        onFolderClick={setCurrentFolderId}
                        onFileClick={handleFileClick}
                        onDeleteClick={(item) => setModal({ type: 'delete', data: item })}
                    />
                    <ActionButtons
                        currentFolderId={currentFolderId}
                        onAddFolderClick={() => setModal({ type: 'addFolder', data: null })}
                        onFileUpload={handleFileUpload}
                    />
                    {modal.type === 'addFolder' && <AddFolderModal onAdd={handleAddFolder} onCancel={() => setModal({ type: null, data: null })} />}
                    {modal.type === 'delete' && <DeleteModal onDelete={handleDelete} onCancel={() => setModal({ type: null, data: null })} itemType={modal.data.type} />}
                    {modal.type === 'processFile' && <FileProcessingModal data={modal.data} onSave={handleSaveProcessedFile} onCancel={() => setModal({ type: null, data: null })} existingFolders={folders.filter(f => f.parentId === null)}/>}
                    {modal.type === 'summarize' && <SummaryModal data={modal.data} onCancel={() => setModal({ type: null, data: null })} />}
                </div>
            );
        }

        function Header({ currentFolder, onBack, onImport, onExport, onSummarize }) {
            return (
                <header className="bg-blue-600 text-white shadow-md p-4 flex items-center justify-between">
                    <button onClick={onBack} className={`p-2 rounded-full hover:bg-blue-700 ${!currentFolder ? 'invisible' : ''}`}>
                        <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>
                    </button>
                    <h1 className="text-xl font-bold text-center truncate">{currentFolder?.name || 'Hauptmenü'}</h1>
                    <div className="flex items-center space-x-2">
                        {currentFolder && (
                            <button onClick={onSummarize} title="Ordner zusammenfassen" className="p-2 rounded-full hover:bg-blue-700"><SparklesIcon /></button>
                        )}
                        <label htmlFor="import-input" className="p-2 rounded-full hover:bg-blue-700 cursor-pointer" title="Daten Wiederherstellen">
                            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                        </label>
                        <input type="file" id="import-input" className="hidden" accept=".json" onChange={onImport} />
                        <button onClick={onExport} title="Daten Sichern" className="p-2 rounded-full hover:bg-blue-700">
                            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                        </button>
                    </div>
                </header>
            );
        }

        function MainContent({ folders, files, onFolderClick, onFileClick, onDeleteClick }) {
            if (folders.length === 0 && files.length === 0) {
                return <main className="flex-grow p-4 overflow-y-auto h-full flex items-center justify-center text-slate-500"><p>Dieser Ordner ist leer.</p></main>;
            }
            return (
                <main className="flex-grow p-4 overflow-y-auto">
                    <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-4">
                        {folders.map(folder => (
                            <div key={folder.id} onClick={() => onFolderClick(folder.id)} className="relative aspect-square bg-white rounded-lg shadow p-2 cursor-pointer text-center flex flex-col items-center justify-center">
                                <FolderIcon />
                                <span className="mt-2 text-sm font-medium text-slate-700 break-words">{folder.name}</span>
                                <div onClick={(e) => { e.stopPropagation(); onDeleteClick({ id: folder.id, type: 'folder' }); }} className="absolute top-1 right-1 p-1 text-slate-400 hover:text-red-500 rounded-full"><DeleteIcon /></div>
                            </div>
                        ))}
                        {files.map(file => {
                            const isPdf = file.name.toLowerCase().endsWith('.pdf');
                            return (
                                <div key={file.id} onClick={() => onFileClick(file)} className="relative aspect-square bg-white rounded-lg shadow p-2 cursor-pointer text-center flex flex-col items-center justify-center">
                                    {isPdf ? <PdfFileIcon /> : <ImageFileIcon />}
                                    <span className="mt-2 text-sm font-medium text-slate-700 break-words">{file.name}</span>
                                    <div onClick={(e) => { e.stopPropagation(); onDeleteClick({ id: file.id, type: 'file' }); }} className="absolute top-1 right-1 p-1 text-slate-400 hover:text-red-500 rounded-full"><DeleteIcon /></div>
                                </div>
                            );
                        })}
                    </div>
                </main>
            );
        }

        function ActionButtons({ currentFolderId, onAddFolderClick, onFileUpload }) {
            return (
                <div className="fixed bottom-6 right-6 flex flex-col items-end space-y-3">
                    {currentFolderId && (
                        <label htmlFor="file-upload-input" className="bg-green-500 hover:bg-green-600 text-white rounded-full w-14 h-14 flex items-center justify-center shadow-lg cursor-pointer" title="Datei in Ordner hochladen">
                            <svg className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M12 15l-4-4m0 0l4-4m-4 4h12" /></svg>
                        </label>
                    )}
                    <input type="file" id="file-upload-input" className="hidden" accept="image/*,.pdf" onChange={(e) => onFileUpload(e.target.files[0])} />
                    <button onClick={onAddFolderClick} className="bg-blue-500 hover:bg-blue-600 text-white rounded-full w-14 h-14 flex items-center justify-center shadow-lg" title="Neuen Ordner erstellen">
                        <svg className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z" /></svg>
                    </button>
                </div>
            );
        }

        function AddFolderModal({ onAdd, onCancel }) {
            const [name, setName] = useState('');
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
                    <div className="bg-white rounded-lg p-6 shadow-xl w-11/12 max-w-sm">
                        <h2 className="text-lg font-bold mb-4">Neuen Ordner erstellen</h2>
                        <input type="text" value={name} onChange={(e) => setName(e.target.value)} className="border rounded-md w-full p-2 mb-4" placeholder="Name des Ordners" autoFocus />
                        <div className="flex justify-end space-x-2">
                            <button onClick={onCancel} className="bg-gray-300 hover:bg-gray-400 text-black px-4 py-2 rounded-md">Abbrechen</button>
                            <button onClick={() => onAdd(name)} className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md">Erstellen</button>
                        </div>
                    </div>
                </div>
            );
        }

        function DeleteModal({ onDelete, onCancel, itemType }) {
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
                    <div className="bg-white rounded-lg p-6 shadow-xl w-11/12 max-w-sm text-center">
                        <h2 className="text-lg font-bold mb-2">Wirklich löschen?</h2>
                        <p className="mb-4 text-slate-600">{`Möchten Sie das ${itemType === 'folder' ? 'Verzeichnis (inkl. Inhalt)' : 'Dokument'} wirklich löschen?`}</p>
                        <div className="flex justify-center space-x-2">
                            <button onClick={onCancel} className="bg-gray-300 hover:bg-gray-400 text-black px-4 py-2 rounded-md">Nein</button>
                            <button onClick={onDelete} className="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md">Ja, löschen</button>
                        </div>
                    </div>
                </div>
            );
        }

        function FileProcessingModal({ data, onSave, onCancel, existingFolders }) {
            const { originalFile, content } = data;
            
            const getFileParts = (fileName) => {
                const lastDotIndex = fileName.lastIndexOf('.');
                if (lastDotIndex === -1) return { base: fileName, ext: '' };
                return { base: fileName.slice(0, lastDotIndex), ext: fileName.slice(lastDotIndex) };
            };

            const [baseName, setBaseName] = useState(getFileParts(originalFile.name).base);
            const [extension, setExtension] = useState(getFileParts(originalFile.name).ext);
            const [originalExtension] = useState(getFileParts(originalFile.name).ext);
            const [folderName, setFolderName] = useState('');
            const [tasks, setTasks] = useState([]);
            const [isLoading, setIsLoading] = useState({ suggestions: false, tasks: false });
            const [error, setError] = useState({ suggestions: '', tasks: '' });

            const getSuggestionsFromGemini = useCallback(async () => {
                setIsLoading(prev => ({ ...prev, suggestions: true }));
                setError(prev => ({ ...prev, suggestions: '' }));
                const topLevelFolders = existingFolders.map(f => f.name).join(', ');
                const prompt = `Analysiere den folgenden Dokumententext und schlage einen passenden Ordner und einen aussagekräftigen Dateinamen vor. Der Dateiname sollte dem Format 'JJJJ-MM-TT_Beschreibung' folgen (ohne Dateiendung). Existierende Hauptordner sind: "${topLevelFolders}". Wenn keiner passt, schlage einen neuen, passenden Ordnernamen vor. Gib deine Antwort als JSON-Objekt. Dokumententext: "${content}"`;
                const schema = { type: "OBJECT", properties: { suggestedFolderName: { type: "STRING" }, suggestedFileNameBase: { type: "STRING" } }, required: ["suggestedFolderName", "suggestedFileNameBase"] };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: schema } };
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error(`API-Fehler: ${response.statusText}`);
                    const result = await response.json();
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const parsedJson = JSON.parse(jsonText);
                    setBaseName(parsedJson.suggestedFileNameBase);
                    setFolderName(parsedJson.suggestedFolderName);
                    setExtension('.pdf');
                } catch (err) {
                    console.error("Fehler bei der Gemini-API-Anfrage:", err);
                    setError(prev => ({ ...prev, suggestions: "Vorschläge konnten nicht geladen werden." }));
                } finally {
                    setIsLoading(prev => ({ ...prev, suggestions: false }));
                }
            }, [content, existingFolders]);
            
            const getTasksFromGemini = useCallback(async () => {
                setIsLoading(prev => ({ ...prev, tasks: true }));
                setError(prev => ({ ...prev, tasks: '' }));
                setTasks([]);
                const prompt = `Basierend auf diesem Dokumententext, schlage 1-3 relevante, ausführbare Aufgaben vor. Beispiel: Für eine Rechnung mit Fälligkeitsdatum, schlage vor, sie zu bezahlen. Gib die Antwort als JSON-Array von Strings. Text: "${content}"`;
                const schema = { type: "ARRAY", items: { type: "STRING" } };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: schema } };
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error(`API-Fehler: ${response.statusText}`);
                    const result = await response.json();
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const parsedJson = JSON.parse(jsonText);
                    setTasks(parsedJson);
                } catch (err) {
                    console.error("Fehler bei der Gemini-API-Anfrage für Aufgaben:", err);
                    setError(prev => ({ ...prev, tasks: "Aufgaben konnten nicht geladen werden." }));
                } finally {
                    setIsLoading(prev => ({ ...prev, tasks: false }));
                }
            }, [content]);

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4">
                    <div className="bg-white rounded-lg p-6 shadow-xl w-full max-w-md">
                        <h2 className="text-lg font-bold mb-4">Datei verarbeiten</h2>
                        <div className="mb-4">
                            <label className="block text-sm font-medium text-gray-700 mb-1">Erkannter Text (simuliert)</label>
                            <textarea className="border rounded-md w-full p-2 h-20 bg-gray-50" readOnly value={content}></textarea>
                        </div>
                        <div className="grid grid-cols-2 gap-2 mb-4">
                            <button onClick={getSuggestionsFromGemini} disabled={isLoading.suggestions} className="w-full flex items-center justify-center bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-md disabled:bg-purple-300">
                                <SparklesIcon /> <span className="ml-2">{isLoading.suggestions ? 'Analysiere...' : '✨ Sortieren'}</span>
                            </button>
                             <button onClick={getTasksFromGemini} disabled={isLoading.tasks} className="w-full flex items-center justify-center bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-md disabled:bg-teal-300">
                                <SparklesIcon /> <span className="ml-2">{isLoading.tasks ? 'Analysiere...' : '✨ Aufgaben'}</span>
                            </button>
                        </div>
                        {error.suggestions && <p className="text-red-500 text-sm text-center mb-2">{error.suggestions}</p>}
                        {error.tasks && <p className="text-red-500 text-sm text-center mb-2">{error.tasks}</p>}
                        {tasks.length > 0 && (
                            <div className="mb-4 p-3 bg-teal-50 border border-teal-200 rounded-lg">
                                <h3 className="text-sm font-bold text-teal-800 mb-2">Vorgeschlagene Aufgaben:</h3>
                                <ul className="list-disc list-inside text-sm text-teal-700 space-y-1">
                                    {tasks.map((task, index) => <li key={index}>{task}</li>)}
                                </ul>
                            </div>
                        )}
                        <div className="mb-4">
                            <label htmlFor="folderName" className="block text-sm font-medium text-gray-700 mb-1">Ordner</label>
                            <input id="folderName" type="text" value={folderName} onChange={(e) => setFolderName(e.target.value)} className="border rounded-md w-full p-2" placeholder="Ordnername" />
                        </div>
                        <div className="mb-6">
                            <label htmlFor="fileName" className="block text-sm font-medium text-gray-700 mb-1">Dateiname</label>
                            <div className="flex">
                                <input id="fileName" type="text" value={baseName} onChange={(e) => setBaseName(e.target.value)} className="border rounded-l-md w-full p-2" placeholder="Dateiname" />
                                <select value={extension} onChange={(e) => setExtension(e.target.value)} className="border-t border-b border-r rounded-r-md p-2 bg-gray-50">
                                    <option value=".pdf">.pdf</option>
                                    {originalExtension !== '.pdf' && <option value={originalExtension}>{originalExtension}</option>}
                                </select>
                            </div>
                        </div>
                        <div className="flex justify-end space-x-2">
                            <button onClick={onCancel} className="bg-gray-300 hover:bg-gray-400 text-black px-4 py-2 rounded-md">Abbrechen</button>
                            <button onClick={() => onSave({ fileName: `${baseName}${extension}`, folderName, originalFile })} className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md">Speichern</button>
                        </div>
                    </div>
                </div>
            );
        }

        function SummaryModal({ data, onCancel }) {
            const { folderName, files } = data;
            const [summary, setSummary] = useState('');
            const [isLoading, setIsLoading] = useState(true);
            const [error, setError] = useState('');

            const getSummaryFromGemini = useCallback(async () => {
                if (files.length === 0) {
                    setSummary("Dieser Ordner enthält keine Dateien, die zusammengefasst werden könnten.");
                    setIsLoading(false);
                    return;
                }
                setIsLoading(true);
                setError('');
                const fileNames = files.map(f => f.name).join(', ');
                const prompt = `Basierend auf der folgenden Liste von Dateinamen aus dem Ordner "${folderName}", erstelle eine kurze Zusammenfassung (1-2 Sätze) über den wahrscheinlichen Inhalt dieses Ordners. Dateinamen: ${fileNames}`;
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error(`API-Fehler: ${response.statusText}`);
                    const result = await response.json();
                    const text = result.candidates[0].content.parts[0].text;
                    setSummary(text);
                } catch (err) {
                    console.error("Fehler bei der Gemini-API-Anfrage:", err);
                    setError("Die Zusammenfassung konnte nicht geladen werden.");
                } finally {
                    setIsLoading(false);
                }
            }, [folderName, files]);

            useEffect(() => {
                getSummaryFromGemini();
            }, [getSummaryFromGemini]);

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4">
                    <div className="bg-white rounded-lg p-6 shadow-xl w-full max-w-md">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-bold">✨ KI-Zusammenfassung</h2>
                            <button onClick={onCancel} className="text-gray-400 hover:text-gray-600">&times;</button>
                        </div>
                        <div className="min-h-[100px]">
                            {isLoading && <p className="text-center text-gray-500">Zusammenfassung wird erstellt...</p>}
                            {error && <p className="text-red-500 text-center">{error}</p>}
                            {!isLoading && !error && <p className="text-gray-700">{summary}</p>}
                        </div>
                        <div className="flex justify-end mt-4">
                            <button onClick={onCancel} className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md">Schließen</button>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
    <script>
        if ('serviceWorker' in navigator) {
            const swContent = `
                const CACHE_NAME = 'akten-ordner-cache-v1';
                const urlsToCache = [
                    '/',
                    '/index.html' // Cache the main file
                ];

                self.addEventListener('install', event => {
                    event.waitUntil(
                        caches.open(CACHE_NAME)
                            .then(cache => {
                                // We are in a single file, so caching the root is enough.
                                // In a real multi-file app, you'd list all files here.
                                return cache.add(location.pathname);
                            })
                    );
                });

                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request)
                            .then(response => {
                                return response || fetch(event.request);
                            })
                    );
                });
            `;
            const swBlob = new Blob([swContent], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(swBlob);

            navigator.serviceWorker.register(swUrl)
                .then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                })
                .catch(error => {
                    console.log('ServiceWorker registration failed: ', error);
                });
        }
    </script>
</body>
</html>
